====== Pango - programátorská dokumentace ======

===== Architektura =====

Program Pango se skládá ze dvou hlavních èástí, a to knihovny a grafického rozhraní. Knihovna poskytuje kompletní objektovou reprezentaci hry. Její sluby vyuívá grafické rozhraní (Windows Forms aplikace), která zajišuje zpracování podnìtù od uivatele a zobrazení aktuálního stavu hry. Herní smyèka probíhá a v grafickém rozhraní. Knihovna i GUI leí v namespace Pango.

==== Knihovna libpango ====

=== Pøehled ===

Oznaèení:
  * hra - skládá se z levelù; konèí, kdy hráè umøe a ji nemá volné ivoty 
  * level - má svou mapu; konèí, kdy hráè zabije všechna monstra

Hra je reprezentována tøídou Game, jednotlivé levely stavy této tøídy. Bìhem jednoho bìhu programu mùe probìhnout více her. Game obsahuje mapu (instance tøídy Map), simulaèní kalendáø (singleton instance tøídy Schedule), stav získanıch penìz a nìkolik eventù.

Základem levelu je mapa, ve které se vyskytují rùzné pøedmìty nebo postavy, souhrnnì entity, které tvoøí celou hieararchii tøíd. Mapa vyuívá objektù pomocnıch tøíd Coordinates a Place. Pro naèítání mapy ze souboru a pro konverzi mezi Map a string slouí tøída MapPersistence, která okrajové vyuívá knihovnu Reader projektu CodEx.

Kalendáø Schedule sleduje herní èas a pøedevším poskytuje monost entitám a jinım objektù naplánovat nìjakou akci na danı herní èas.

Tøída Config slouí k oddìlení nastavení (vìtšinou rùznıch èíselnıch parametrù) od samotného kódu. Nastavení tak mùe leet i mimo program a zmìny mohou bıt persistentnì uloeny.

=== Game ===

Tøída Game reprezentuje hru a její levely. Je pouit návrhovı vzor Singleton, jediná instance staèí a je jednoduše pøístupná.

Stavy hry: Prepared, Running, Paused, Finished. Game obsahuje mapu, rozvrh, level, stav penìního skóre a odkaz na entitu hráèe (zatím pouze single-player). Game nabízí nìkolik eventù, na které se mohou navìsit funkce z grafického rozhraní.

Pouití:
  * do Config.Instance["Game.map"] se vloí mapa jako text
  * pouije se instance Game.Instance
  * pomocí Game.Instance.loadMap() se vytvoøí mapa z configu
  * na eventy se zavìsí vlastní funkce  
  * kroky smyèky se volají pøes step()
Rohzraní:
  * static Game Instance - pøístup k singleton instanci
  * Map Map
  * Schedule Schedule
  * States State
  * int Time 
  * int Money
  * int Level
  * PlayerEntity Player
  * void loadMap() - naète mapu z Config a nastaví odkaz na hráèe
  * void start() - spustí hru, event onStart
  * void endLevel() - konec levelu; pøechod dál, nebo konec hry, event onEnd
  * void endGame() - konec hry, event onEnd
  * void pause() - pozastavení nebo opìtovné spuštìní hry, event OnPause
  * bool step()
    - krok herní smyèky, event onLoopStep
		- vrací true, kdy aspoò jedna entita nìco provede
		- asi nejdùleitìjší èást tøídy Game
  * void receiveMoney(int) - pøidá hráèi danou èástku penìz
Pomocné vìci:
  * void addRandomBonuses() - na náhodné prùchozí políèko pøidá náhodnı bonus
  * void newGame()
  * void nextLevel()		  

=== Map a její pomocné tøídy ===

== Map ==

Mapa jednoho levelu. Obsahuje políèka s entitami. Rovnì si pamatuje poèet prùchozích políèek a seznamy monster a bonusù, pro rychlejší procházení.

Rozhraní:
  * Map(int width, int height) - vytvoøí prázdnou mapu dané velikosti
  * Map(Entity[,]) - vytvoøí mapu z pole entit (napø. naèteného ze souboru)
  * Place[,] Places
  * int Height
  * int Width
  * List<MonsterEntity> Monsters - seznam monster
  * List<BonusEntity> Bonuses - seznam bonusovıch entit
  * bool add(Entity, Coordinates) - pøidá entitu na dané souøadnice
  * bool add(Entity, Place) - pøidá entitu na dané políèko
  * bool remove(Entity, Coordinates) - odstraní entitu z daného políèka
  * bool remove(Entity) - odstraní entitu z mapy
  * bool isWalkable(Coordinates) - true, je-li pole prùchozí
  * bool isSmitable(Coordinates) - true, pokud lze pole prosvištìt ledem
  * bool move(Entity, Coordinates from, Coordinates to) - pøesune entitu 
  * Coordinates find(Entity) - najde danou entitu v mapì, nebo vrátí neplatné souøadnice
  * bool hasEntity(Entity) - true, pokud se daná entita vyskytuje nìkde v mapì 
  * bool hasEntity(Entity, Coordinates) true, pokud se daná entita vyskytuje na daném políèku
  * IEnumerator<Entity> GetEnumerator() - iterátor entitami v mapì
  * Place getPlace(Coordinates) - vrátí políèko na danıch souøadnicích
  * List<Entity> getNeighbors(Coordinates) - vrátí seznam sousedních entiti
  * bool areValidCoordinates(Coordinates) - true, leí-li souøadnice na mapì
  * Coordinates getRandomWalkablePlace() - vrátí náhodné souøadnice na mapì
  * string ToString() - pøevod na textovou reprezentaci

== MapPersistence ==

Slouí pro pøevod mezi Map a string, tj. naèítání mapy ze souboru a textové zobrazení mapy. Obsahuje vlastní pøevodní tabulky.

Rozhraní:
  * static Map FromString(string) - pøevod textu na mapu
  * static string ToString(Map) - pøevod mapy na text
  * static string readMapFromFile(string) - ètení mapy ze souboru	 

== Coordinates ==

Objekty této tøídy reprezentují dvourozmìrné souøadnice v mapì, pøípadnì neplatné souøadnice. Pomocí nich se adresují políèka mapy a kadá entita si pomocí nich navíc udruje svoji pozici.

Souøadnice se poèítají od nuly, x je vertikální sloka (smìrem shora dolù), y horizontální (smìrem zleva doprava). 

Coordinates nabízí i jednoduchou aritmetiku mezi souøadnicemi a smìry.
Rozhraní:
  * int x, y - sloky souøadnic
  * bool inInvalid - pøíznak neplatné souøadnice
  * static Coordinates invalid - neplatné souøadnice   
  * Coordinates(int, int)  
  * static Coordinates operator +(Coordinates, Coordinates)
  * static Coordinates operator -(Coordinates, Coordinates)
  * static Nullable<Direction> diffDirection(Coordinates, Coordinates)
    - smìr jako rozdíl dvou sousedních souøadnic, jinak null
  * bool Equals(Coordinates)
	* static bool areNeighbors(Coordinates, Coordinates)
	* bool isNeighbor(Coordinates)
	* static Coordinates step(Coordinates, Direction)
	* Coordinates step(Direction dir)
	  
== Place ==

Reprezentuje jedno políèko na mapì. Zajímavé je, e mùe obsahovat a dvì entity - jednu prùchozí (walkable - potomka tøídy WalkableEntity) a jednu neprùchozí. To se napø. hodí, jakmile mostrum (non-walkable) chce projít pøes bonus (walkable), ale nebude jej sbírat. Zøejmì staèí nejvıš jedna entita kadého druhu, jinak by nastal na mapì zmatek a hra by se stala dosti neintuitivní.

Rozhraní:
  * Walkable, NonWalable - properties pro pøístup k entitám
  * bool add(Entity) - pøidá entitu (a správnì zaøadí podle druhu)
  * bool remove(Entity) - vymae zadanou entitu, pokud byla na políèku
  * bool isWalkable() 
  * bool contains(Entity)
  * IEnumerator<Entity> GetEnumerator() - iterátor pøes entity na políèku			 

== enum Direction ==

Reprezentuje smìr. Lze pøevést na int a zpìt.
Up = 0, Right, Down, Left.

== enum Rotation ==

Reprezentuje úhel rotace. Lze pøevést na int a zpìt.
Forward = 0, CW, Backwards, CCW.

== DirectionUtils ==

Umoòuje provádìt rotaci smìru a pøevod smìru na souøadnice. Direction i Rotation jsou vıètového typu, protoe je nenároèné je pøevádìt na èíslo a zpìt. Jejich hodnot je jen konstatnì mnoho (resp. málo) tudí není nutné pro nì neustále vytváøet a rušit stejné objekty.
Rozhraní:
  * static int Count - poèet smìrù (pro prùchod smìry)
  * static Direction rotate(Direction, Rotation) - otoèí danı smìr o danou rotaci
  * static Coordinates step(Direction)
    - pø. smìr Up pøevede na Coordinates (-1,0)  

=== Entity a jejich hierarchie ===

Entity reprezentují vìci nebo postavy, které se vyskytují na mapì.

Hierarchie:

* abstract Entity
	* abstract MovableEntity
		* abstract LiveEntity
			* PlayerEntity
			* MonsterEntity
		* abstract MovableBlock
			* DiamondBlock
			* IceBlock
	* abstract WalkableEntity
		* abstract BonusEntity
			* MoneyBonus
			*	HealthBonus
			* LiveBonus
	* StoneBlock

Pouity abstraktní tøídy místo rozhraní, kvùli pøidávání dalších fields.

== Entity ==

Základ pro všechny entity.

Rozhraní:
  * Coordinates Coords - udrování pozice uvnitø entity se obèas hodí
  * bool turnDone - pouívá se, aby v jednom kroku entita nehrála vícekrát
  * abstract bool turn() - akce, kdy entita dostane "tah" (v kadém kroku)
  * abstract void acceptAttack(Entity sender, int hitcount)
    - volá útoèník na entitu, kdy jí napadne  
  * void vanish() - entita se vymae z mapy

== MovableEntity ==

Entity, které se mohou pohybovat.

Rozhraní:
  * Direction Direction - aktuální smìr pohybu
  * bool go()
    - provedení jednoho kroku v aktuálním smìru
    - vrátí true, kdy se krok podaøilo provést
	* virtual bool canGo(Coordinates) - true, pokud lze jít v aktuálním smìru
	* void rotate(Rotation) - otoèení o danı úhel

== LiveEntity ==

ivé entity mající zdraví, ivoty, mohou bıt zranìny, zabity a znovu oít.

Rozhraní:
  * int Health
  * int MaxHealth
  * int Lives
  * abstract void die() - na smrt mohou konkrétní entity reagovat rùznì
  * virtual bool changeHealth(int change) - zmìna zdraví má vliv jak na zdraví, tak i na poèet volnıch ivotù
  * void respawn(LiveEntity newborn) - na náhodné místo umístí novou entitu				  

== WalkableEntity ==

Prùchozí entita. Jiné entity mohou vstoupit na stejné políèko jako tato. Hodí se napøíklad, kdy monstrum vstoupí na bonus, ale nechceme aby jej sebral.

Tato tøída nijak nemìní rozhraní, uívá se pouze pomocí klíèového slova 'is'.

== MovableBlock ==

Neprùchozí entita, která se za urèitıch podmínek mùe pohybovat. Hodí se pro bloky ledové bloky a diamanty, do nich mùe hráè kopat.

Má dva stavy: Rest a Movement.

Implementuje:
  * bool turn() - pøi pohybu zabije ivé entity po cestì a zastaví se a o neivou entitu
  * bool canGo(Coordinates) - pokraèovat lze, splòuje-li políèko isSmitable()
  * void acceptAttack(Entity sender, int hitcount)		  

Rozhraní:
  * protected abstract void acceptAttackCantGoHook()
  * protected abstract void turnCantGoHook()  

== PlayerEntity ==

Hráè. Zatím je hra Pango navrena pouze pro single-player. 

Implementuje:
  * bool turn() - zpracuje poadavky uivatele a provádí interakci s ostatními entitami na políèku
  * void acceptAttack(Entity sender, int hitcount) 
  * void die() - respawnuje hráèe nebo ukonèí celou hru 

Rozhraní:
  * public PlayerEntity()
  * layerEntity(PlayerEntity) - copy constructor se hodí pøi respawnu nebo pøechodu do nového levelu
  * void requestMovement(Direction) - volá obsluha klávesovıch stiskù
  * void requestAttack()  

== MonsterEntity ==

Monstra, protivníci hráèe. Stavy: Normal, Stunned, Egg (Monstrum se líhne z vejce a lze jej omráèit). Pro chùzi je nyní pouit algoritmus ze cvièení Programování II s pøidanou náhodnou rotací. 

Implementuje:
  * bool turn() - zde monstrum chodí po bludišti a zkouší zaútoèit na hráèe  
  * void acceptAttack(Entity sender, int hitcount)
  * void die()	  

Rozhraní:
  * MonsterEntity() - naplánuje vylíhnutí
  * void stun(int time) - mostrum se na chvíli omráèí

== DiamondBlock ==

Diamant. Chová se jako ledovı blok, ale netaje. Nìkolik diamantù poskládanıch do øady dá bonus a omráèí všechna monstra.

Implementuje:
  * void acceptAttackCantGoHook() - nic nedìlá
  * void turnCantGoHook() - kontroluje poskládání do øady  

== IceBlock ==

Ledovı blok. Hráè do nìj mùe kopnout a tím jej uvést do pohybu. Nemá-li kam jít, roztaje.

Implementuje:
  * void acceptAttackCantGoHook() - tání
  * void turnCantGoHook() - nic nedìlá  

== BonusEntity ==

Základ pro všechny bonusové entity. Má omezenou ivotnost (int timeToLive).

Rozhraní:
  * abstract void giveBonus(PlayerEntity) - hráè si vyzvedne bonus, kdy na nìj narazí

== MoneyBonus, HealthBonus, LiveBonus ==

Bonusy ve formì penìz, zdraví resp. volnıch ivotù. Rùznì implementují giveBonus().

=== Schedule ===

Udruje herní èas (poèítanı v krocích) a slouí pro plánování akcí, které se mají provést po urèitém poètu herních krokù. Obsahuje prioritní frontu, kde prioritou je právì herní krok. Akce, vìtšinou definované jako anonymní funkce, se ukládají jako C# delegate (obdoba ukazatele na funkci).
Dùleité prvky rozhraní:
  *  void add(EventDelegate eh, int timeoffset) - naplánuje akci
  *  void callCurrentEvents() - provede akce pro aktuální èas
  *  int Time - aktuální èas

=== Config ===

Slouí pro správu nastavení. Obsahuje slovník párù <string,string> pro snadné adresování. Tøída pouívá návrhovı vzor Singleton a je tak snadno pøístupná.

==== Grafické rozhraní ====

=== Pøehled ===

Jde o Windows Forms aplikaci. Má tøi úkoly:
  * pomocí knihovny inicializovat hru a spouštìt herní smyèku
  * zpracovávat stisky kláves
  * zobrazovat mapu a údaje o høe
Herní smyèka vyuívá èasovaèe z Forms. Na eventy v Game pøipojuje svoje metody pro vykreslování a manipulaci s èasovaèem.

GUI obsahuje dvì tøídy Program a PangoGameForm.

=== Program ===

=== PangoGameForm ===

Form s hlavním oknem aplikace. Z komponent obsahuje PictureBox, do nìj se kreslí mapa, ImageList pro uloení obrázkù entit, StatusStrip pro zobrazení informací o stavu hry. Dále obsahuje obsluhy událostí pro vykreslovaní mapy a zpracování klávesového vstupu.

Rozhraní:
  * void refreshStatusLabels(object sender, EventArgs e)
  * void repaintMapPictureBox(object sender, EventArgs e)
  * void refresh() - obnoví mapu i status strip, lze volat pøímo  
  * void setWindowSize(object sender, EventArgs e)
    - nastaví velikost okna podle velikosti mapy		  
Další vìci:
  * private void processKeyboardInput(object sender, KeyEventArgs e)
  * private void mapPictureBox_Paint(object sender, PaintEventArgs e)
	  - pro entity v políèkách vybere z ImageListu vhodnı obrázek podle jejich stringové reprezentace

=== Program ===

V této statické tøídì se inicializuje a spustí hra. Tøída obsahuje Timer (z Windows Forms), nìkolik obsluh událostí. Zde je propojena tøída Game s PangoGameForm.

Rozhraní:
  * static void Main()
Další vìci:
  * static Windows.Forms.Timer timer - èasovaè z Windows Forms, kterı bere ohled na vlákna v GUI aplikaci. Lze pouít jednodušeji ne obyèejnı èasovaè.
  * static void initializeGame(PangoGameForm)
    - inicializuje hru
		- namapuje obsluhy eventù v Game  
  * static void stop() - zastaví èasovaè, lze volat pøímo
  * static void gameStart(object sender, EventArgs e)
    - v èasovaèi naplánuje gameStep  
	* static void gamePause(object sender, EventArgs e)
    - zastaví èasovaè, obsluha eventu
  * static void gameStep(object sender, EventArgs e)
    - provede krok hry a znovu se naplánuje
